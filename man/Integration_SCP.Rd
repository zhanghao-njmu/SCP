% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/SCP-workflow.R
\name{Integration_SCP}
\alias{Integration_SCP}
\title{Integration_SCP}
\usage{
Integration_SCP(
  srtMerge = NULL,
  batch,
  append = TRUE,
  srtList = NULL,
  assay = NULL,
  integration_method = "Uncorrected",
  do_normalization = NULL,
  normalization_method = "LogNormalize",
  do_HVF_finding = TRUE,
  HVF_source = "separate",
  HVF_method = "vst",
  nHVF = 2000,
  HVF_min_intersection = 1,
  HVF = NULL,
  do_scaling = TRUE,
  vars_to_regress = NULL,
  regression_model = "linear",
  scale_within_batch = FALSE,
  linear_reduction = "pca",
  linear_reduction_dims = 50,
  linear_reduction_dims_use = NULL,
  linear_reduction_params = list(),
  force_linear_reduction = FALSE,
  nonlinear_reduction = "umap",
  nonlinear_reduction_dims = c(2, 3),
  nonlinear_reduction_params = list(),
  force_nonlinear_reduction = TRUE,
  neighbor_metric = "euclidean",
  neighbor_k = 20L,
  cluster_algorithm = "louvain",
  cluster_resolution = 0.6,
  seed = 11,
  ...
)
}
\arguments{
\item{srtMerge}{A merged Seurat object that includes the batch information.}

\item{batch}{A character string specifying the batch variable name.}

\item{append}{Logical, if TRUE, the integrated data will be appended to the original Seurat object (srtMerge).}

\item{srtList}{A list of Seurat objects to be checked and preprocessed.}

\item{assay}{The name of the assay to be used for downstream analysis.}

\item{integration_method}{A character string specifying the integration method to use.
Supported methods are: \code{"Uncorrected"}, \code{"Seurat"}, \code{"scVI"}, \code{"MNN"}, \code{"fastMNN"}, \code{"Harmony"},
\code{"Scanorama"}, \code{"BBKNN"}, \code{"CSS"}, \code{"LIGER"}, \code{"Conos"}, \code{"ComBat"}. Default is \code{"Uncorrected"}.}

\item{do_normalization}{A logical value indicating whether data normalization should be performed.}

\item{normalization_method}{The normalization method to be used. Possible values are "LogNormalize", "SCT", and "TFIDF". Default is "LogNormalize".}

\item{do_HVF_finding}{A logical value indicating whether highly variable feature (HVF) finding should be performed. Default is TRUE.}

\item{HVF_source}{The source of highly variable features. Possible values are "global" and "separate". Default is "separate".}

\item{HVF_method}{The method for selecting highly variable features. Default is "vst".}

\item{nHVF}{The number of highly variable features to select. Default is 2000.}

\item{HVF_min_intersection}{The feature needs to be present in batches for a minimum number of times in order to be considered as highly variable. The default value is 1.}

\item{HVF}{A vector of highly variable features. Default is NULL.}

\item{do_scaling}{A logical value indicating whether to perform scaling. If TRUE, the function will force to scale the data using the ScaleData function.}

\item{vars_to_regress}{A vector of variable names to include as additional regression variables. Default is NULL.}

\item{regression_model}{The regression model to use for scaling. Options are "linear", "poisson", or "negativebinomial" (default is "linear").}

\item{scale_within_batch}{Whether to scale data within each batch. Only valid when the \code{integration_method} is one of \code{"Uncorrected"}, \code{"Seurat"}, \code{"MNN"}, \code{"Harmony"}, \code{"BBKNN"}, \code{"CSS"}, \code{"ComBat"}.}

\item{linear_reduction}{The linear dimensionality reduction method to use. Options are "pca", "svd", "ica", "nmf", "mds", or "glmpca" (default is "pca").}

\item{linear_reduction_dims}{The number of dimensions to keep after linear dimensionality reduction (default is 50).}

\item{linear_reduction_dims_use}{The dimensions to use for downstream analysis. If NULL, all dimensions will be used.}

\item{linear_reduction_params}{A list of parameters to pass to the linear dimensionality reduction method.}

\item{force_linear_reduction}{A logical value indicating whether to force linear dimensionality reduction even if the specified reduction is already present in the Seurat object.}

\item{nonlinear_reduction}{The nonlinear dimensionality reduction method to use. Options are "umap","umap-naive", "tsne", "dm", "phate", "pacmap", "trimap", "largevis", or "fr" (default is "umap").}

\item{nonlinear_reduction_dims}{The number of dimensions to keep after nonlinear dimensionality reduction. If a vector is provided, different numbers of dimensions can be specified for each method (default is c(2, 3)).}

\item{nonlinear_reduction_params}{A list of parameters to pass to the nonlinear dimensionality reduction method.}

\item{force_nonlinear_reduction}{A logical value indicating whether to force nonlinear dimensionality reduction even if the specified reduction is already present in the Seurat object.}

\item{neighbor_metric}{The distance metric to use for finding neighbors. Options are "euclidean", "cosine", "manhattan", or "hamming" (default is "euclidean").}

\item{neighbor_k}{The number of nearest neighbors to use for finding neighbors (default is 20).}

\item{cluster_algorithm}{The clustering algorithm to use. Options are "louvain", "slm", or "leiden" (default is "louvain").}

\item{cluster_resolution}{The resolution parameter to use for clustering. Larger values result in fewer clusters (default is 0.6).}

\item{seed}{An integer specifying the random seed for reproducibility. Default is 11.}

\item{...}{Additional arguments to be passed to the integration method function.}
}
\value{
A \code{Seurat} object.
}
\description{
Integrate single-cell RNA-seq data using various integration methods.
}
\examples{
data("panc8_sub")
panc8_sub <- Integration_SCP(
  srtMerge = panc8_sub, batch = "tech",
  integration_method = "Uncorrected"
)
CellDimPlot(panc8_sub, group.by = c("tech", "celltype"))

panc8_sub <- Integration_SCP(
  srtMerge = panc8_sub, batch = "tech",
  integration_method = "Uncorrected",
  HVF_min_intersection = 5
)
CellDimPlot(panc8_sub, group.by = c("tech", "celltype"))

panc8_sub <- Integration_SCP(
  srtMerge = panc8_sub, batch = "tech",
  integration_method = "Uncorrected",
  HVF_min_intersection = 5, scale_within_batch = TRUE
)
CellDimPlot(panc8_sub, group.by = c("tech", "celltype"))

panc8_sub <- Integration_SCP(
  srtMerge = panc8_sub, batch = "tech",
  integration_method = "Seurat"
)
CellDimPlot(panc8_sub, group.by = c("tech", "celltype"))

panc8_sub <- Integration_SCP(
  srtMerge = panc8_sub, batch = "tech",
  integration_method = "Seurat",
  FindIntegrationAnchors_params = list(reduction = "rpca")
)
CellDimPlot(panc8_sub, group.by = c("tech", "celltype"))

\dontrun{
integration_methods <- c(
  "Uncorrected", "Seurat", "scVI", "MNN", "fastMNN", "Harmony",
  "Scanorama", "BBKNN", "CSS", "LIGER", "Conos", "ComBat"
)
for (method in integration_methods) {
  panc8_sub <- Integration_SCP(
    srtMerge = panc8_sub, batch = "tech",
    integration_method = method,
    linear_reduction_dims_use = 1:50,
    nonlinear_reduction = "umap"
  )
  print(CellDimPlot(panc8_sub,
    group.by = c("tech", "celltype"),
    reduction = paste0(method, "UMAP2D"),
    xlab = "", ylab = "", title = method,
    legend.position = "none", theme_use = "theme_blank"
  ))
}

nonlinear_reductions <- c("umap", "tsne", "dm", "phate", "pacmap", "trimap", "largevis", "fr")
panc8_sub <- Integration_SCP(
  srtMerge = panc8_sub, batch = "tech",
  integration_method = "Seurat",
  linear_reduction_dims_use = 1:50,
  nonlinear_reduction = nonlinear_reductions
)
for (nr in nonlinear_reductions) {
  print(CellDimPlot(panc8_sub,
    group.by = c("tech", "celltype"),
    reduction = paste0("Seurat", nr, "2D"),
    xlab = "", ylab = "", title = nr,
    legend.position = "none", theme_use = "theme_blank"
  ))
}
}

}
\seealso{
\code{\link{Seurat_integrate}} \code{\link{scVI_integrate}} \code{\link{MNN_integrate}} \code{\link{fastMNN_integrate}} \code{\link{Harmony_integrate}} \code{\link{Scanorama_integrate}} \code{\link{BBKNN_integrate}} \code{\link{CSS_integrate}} \code{\link{LIGER_integrate}} \code{\link{Conos_integrate}} \code{\link{ComBat_integrate}} \code{\link{Standard_SCP}}
}
